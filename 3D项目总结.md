# Printor 3D打印机软件系统 项目总结

## 前言

对3D打印机web前端部分做一个总结，本项目从1月份开始接手，直到三月下旬完成关键需求和功能点，成功部署到服务器上线。从最开始仅有的一点vue的基础，到后来需要用到什么就学什么，进而学习和接触了vuex、vue-router、webGL、threejs、http（跨域、请求）、cookie、JWT还有一些零零散散的js、node的知识。下面对项目需要注意的一些点、自己遇到过的一些坑进行记录。

## 关于包管理

npm包管理是一种模块化管理手段，我们安装node之后就可以在脚手架中运用包管理安装和引入、卸载。包说明文件是`package.json`，定义了这个项目所需要的各种模块，其中有一个非常重要的属性，叫做：`dependencies`，该属性是一个对象，里面保存了当前项目的依赖项，该字段一般不要手动修改，它需要结合 `npm install --save 包名` 来使用，只要在安装的时候加上 `--save` 参数就会自动将包依赖项添加到该属性中，很方便。甚至还可以完全把 `node_modules` 目录删除掉，只要 `package.json` 文件还在，就可以执行 `npm install` 安装包说明文件中的所有的依赖项。

但在做项目的过程中其实会遇到一些问题，在vue cli run的时候，有时候会报错说哪个模块找不到了。其实我们如果用npm i 安装某一模块的时候，`node_modules`是不能自动更新的（或许还有更新命令我不知道的？），像`npm update`这条指令好像只能更新`node_modules`里面已有包的版本。所以每次安装项目所需模块，就要手动删除node_modules文件夹，然后再重新`npm i`，这样才不会报错。

脚手架要run起来，node_modules文件夹是必须的。但git推送上去的时候，node_modules是不会推上去的，node_modules文件夹是很大的，一般保留了package文件就能安装相应模块了，推送屏蔽的文件和文件夹在.gitignore这个文件中定义了。

## 关于vue脚手架和打包至服务器部署

我们使用的cli版本是3.x的。和2.x有很多区别，比如，我们在新建项目的时候，完全可以使用vue ui图形化界面，更加友好，省去了很多命令，一些必要的模块配置和记录一目了然。相比较2.x，3.x的文件目录发生了一些变化，比如说不能够直接看到webpack的配置，我们需要手动配置 webpack，在根目录下新建一个 `vue.config.js` 文件。但幸运的是，官方cli文档对配置有很友好的说明。

由于打包部署服务器的需要，我们要注意适应后端框架的目录结构进行打包，比如说config文件配置中，文件输出路径publicPath、放置静态资源的assetsDir、index的路径indexPath都是要调配好的，这里还要注意的是，通过cdn方式引入的一些js、css资源，在`index.js`中也要注意路径的调整，否则丢给后端部署的时候就是各种404或者网页打开来一片空白。

项目打包部署注意点：

1. 路由哈希模式设定为历史模式
2. publicPath目录配置
3. 是否设定假cookie用于屏蔽路由跳转拦截
4. index.html外联标签路径设定
5. 各接口url是否正常配置
6. 压缩包命名，版本记录等

## 关于vue和router

### 生命周期

在做项目的过程中，常常会遇到一些生命周期的坑，但其实理解了网页加载的过程，或者浏览器渲染原理，就很好理解为什么有时候在不适合的时期做不适合的事情，会达不到想要的效果了。

这里还是要举两个栗子的。

1. chart.js引入的图表需要放到`beforeUpdate`中初始化，dom没有构建完毕无法初始化图表，不能获取到dom对象。
2. 页面跳转监听vuex状态，是监听不到的，因为组件没有加载完成，不能够使用监听器或者computed。

### router模式

哈希模式和历史模式的区别

hash模式背后的原理是`onhashchange`事件,可以在window对象上监听这个事件:

```js
window.onhashchange = function(event){
     console.log(event.oldURL, event.newURL);
     let hash = location.hash.slice(1); 
     document.body.style.color = hash;
}
```

上面的代码可以通过改变hash来改变页面字体颜色，虽然没什么用，但是一定程度上说明了原理。
 更关键的一点是，因为hash发生变化的url都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用了，同时点击后退时，页面字体颜色也会发生变化。

`hashchange`只能改变#后面的url片段，而history api则给了前端完全的自由，切换历史状态包括back、forward、go，三个方法，对应浏览器的前进，后退，跳转操作。通过history api，我们丢掉了丑陋的#，但是它也有个问题：不怕前进，不怕后退，就怕**刷新**，**f5**，（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的,不玩虚的。
 在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题.但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。好在router官方文档给出了解决方案，后端配置部分是由后端人员完成的，这部分我就不阐述了，最终完美解决了404的问题。

### 导航守卫

路由拦截器固然好用，项目中我用它来执行进度条动画、判断登录状态拦截跳转。值得注意的是，我在写这部分逻辑的时候，遇到过网页循环跳转（自己跳转到自己的路由），类似于无限递归，导致getCookie的时候爆栈又一直找不到原因。所以条件语句判断要思考清楚。



## 关于前后端对接

除了上文所提到的router模式的问题，最开始对接的时候，我们遇到的是跨域的问题，前端使用的是axios来执行ajax的，必要的时候也可以在header进行属性配置。后端用的是egg框架，后端完成跨域配置之后，就不再出现问题了。

读懂http状态码也是很重要的，404的时候我通常会去找我的请求路径有没有写对，500的时候我一般会告诉后端他那边接收出现了问题，200是我们最希望看到的，也就是对接成功。

对接过程中数据的格式和数据的保存也是很重要的，比如我们选择json传输普通数据，formdata来存放文件（stl或者图片）。后端丢给前端的文档要每一行都仔细看，数据类型、键名都是规定好的。

## 开发技术难点和解决方法

**模型比例调整**

主要的难点在于模型为1:1:1的时候模型是不会超出网格的（y轴，和电脑屏幕垂直的面是x-z面），但是比例超过1的时候会超过y轴，也就是最下面的平面。另外，模型要实现比例大小的调整，必须更新dom，也就是删除掉原来的那个模型，重新加载，即使是放大1%也是一个无限量，所以会爆栈。

首先，我做了一个可拖动的调整进度条，用offsetX，鼠标按下的时候获取起点，移动了多少用getMouseXY和起点相减，再取整转换到 CSS定位上。需要注意的是，三个鼠标事件：down绑定在拖动按钮上，move和up尽量绑定在父级元素上，这是为了扩大拖动时鼠标可以移动的范围。

对爆栈的问题，我把连续量变成离散量来做，用户调整完放开鼠标才更新模型大小。

超出y轴的问题，在初始化模型的时候，对模型位置进行判断，boundbox.min.y即为模型y轴最小的那个值，乘以调整的比例，再减去600（应该是网格高度？），用mesh.position.set调整模型到中心，并且不会超出网格。

**购物车数据传输**

难点在于传输文件和数据，以及如何区分文件来自服务器还是用户上传，我把两个接口分别部署到在线打印组件和购物车组件，在购物车组件中，把订单的信息通过computed存到一个对象中维护（购物车的订单的增删，还有用户勾选的状态改变），购物车的接口就是用来传输这个信息对象的。

在线打印组件的接口是用来传输文件的，在确定下单的时候，首先处理各异常情况，然后再用一个for循环遍历文件数组，用mNo来区别是来自服务器的STL文件还是个人上传的，这个是和后台约定好的，mNo为-1时就是需要触发上传文件的接口；如果不是，就是从服务器来的，就不用触发这个接口，仅上传订单信息。

**用户登录及登录状态**

用vuex做状态管理，储存用户名和登录状态，然后再实时更新这个状态（跳转和首次进入页面的时候更新）。更新状态的方法是，后台给前端一个接口，用来验证cookie中是否有token或者token是否过期，返回状态码给前端。由于首次进入页面和跳转都可以用路由守卫拦截到，所以把状态更新接口放在了路由守卫。在线建模页面也要做登录状态判断，要用超链接（a标签的href），不能用vue-router的push。

