# Vue

- watch与computed的区别

  > `computed` 是计算属性，依赖其他属性计算值，并且 `computed` 的值有缓存，只有当计算值变化才会返回内容。 
  >
  >  `watch` 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。 
  >
  >  所以一般来说需要依赖别的属性来动态获得值的时候可以使用 `computed`，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 `watch`。 

- vue生命周期及对应的行为

  - 在 `beforeCreate` 钩子函数调用的时候，是获取不到 `props` 或者 `data` 中的数据的，因为这些数据的初始化都在 `initState` 中。
  - 然后会执行 `created` 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。
  - 接下来会先执行 `beforeMount` 钩子函数，开始创建 `VDOM`，最后执行 `mounted` 钩子，并将 `VDOM`渲染为真实 `DOM` 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。
  - 接下来是数据更新时会调用的钩子函数 `beforeUpdate` 和 `updated`，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。
  - 另外还有 `keep-alive` 独有的生命周期，分别为 `activated` 和 `deactivated`。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `actived` 钩子函数。
  - 最后就是销毁组件的钩子函数 `beforeDestroy` 和 `destroyed`。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 `destroyed` 钩子函数

- vue父子组件生命周期执行顺序

   父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载 。 所以在父组件`mounted`中获取api的数据，子组件的`mounted`是拿不到的 。

  <img src="C:\Users\NHT\Desktop\前端复习\img\父子组件.png" alt="父子组件" style="zoom:67%;" />

- 组件间通讯方法

- 如何实现一个指令

- vue.nextTick实现原理

- diff算法，虚拟dom为什么快

  - vdom能够使得只更新改变的那一小部分dom，减少重排
  - vdom是一棵抽象语法树
  - 先比较同级层，再比较下一层

- 如何做到的双向绑定

   https://blog.csdn.net/zhenghaohan1999/article/details/100975584 

  双向：

  - data被劫持，修改的时候更新dom
  - dom通过绑定事件（比如input事件），修改data

- 如何设计一个组件

- vue3.0

  - 更小
    - 从面向对象到function-base（函数式编程），提倡组合大于继承（JS的优势），
    - **tree-shaking，按需引入**。而vue2.x只有一个vue实例，很多注册到全局的东西即使不需要也没办法扔掉。
  - **更快**
    - **修改了虚拟dom的算法：从之前的每次更新都要进行一次完整的遍历对比，改为了切分区块树，进行动态更新。只diff（对比）有变化的层，6倍速度。**
    - proxy对于JS引擎更加友好，响应更高效
  - **typescript**
  - Api一致性（留了一个兼容版本作为过渡）
  - 提高可维护能力
  - **开放更多底层功能**