# 通识

1. 三次握手与四次挥手

2. HTTP2

3. HTTP状态码

   <hr>

4. 若无向图G = (V,E)中含7个顶点，则保证图G在任何情况下都是连通的，则需要的边数最少是（）

   由公式n*(n-1)/2+1，七个顶点n取6，答案为16。

   思路是这样的：那么先让 6 个点**完全连通**（任意两个点都能连线），所谓完全就是每个点能够支出的边是满的，这样 6 个点的情况下，边和点的关系是满的。其边的数量由公式 n *(n-1)/2 得出（无向完全连通图边公式），也就是 6 * 5/2=15

   那么此时，我多了一个点，7 号点，只需要在那 6 个点的图中连**一根边**过来，7 号点就可以访问任意 6 点图中的点了。

5.  **TCP与UDP的区别**

   - 连接方面区别

     TCP[面向连接](https://www.baidu.com/s?wd=面向连接&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)（如打电话要先拨号建立连接）。

     UDP是无连接的，即发送数据之前不需要建立连接。

   - 安全方面的区别

     TCP提供可靠的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达。

     UDP尽最大努力交付，即不保证可靠交付。

   - 连接对象数量的区别

     TCP连接只能是点到点、一对一的。

     UDP支持一对一，一对多，多对一和多对多的交互通信（广播通信）。

6. TCP和HTTP的关系

   - TCP是传输层协议，定义数据传输和连接方式的规范。握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

   - HTTP 超文本传送协议(Hypertext Transfer Protocol )是应用层协议，定义的是传输数据的内容的规范。

   - HTTP协议中的数据是利用TCP协议传输的(基于TCP的)，特点是客户端发送的每次请求都需要服务器回送响应，它是TCP协议族中的一种

7. **各层的功能**

   - 应用层（数据交流，提供接口以使程序能使用网络服务 ）

     应用层确定进程之间通信的性质以满足用户的需要。应用层不仅要提供应用进程所需要的**信息交换和远地操作**，而且还要作为互相作用的应用进程的用户代理（user agent),来完成一些为进行语义上有意义的信息交换所必须的功能。

   - 运输层（数据传输、通信）

     任务是**负责主机中两个进程间的通信**。因特网的运输层可使用两种不同的协议。即面向连接的传输控制协议TCP 和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付。无连接服务则不能提供可靠的交付，尽最大努力交付。

   - 网络层

     网络层负责为分组交换网上交换的**不同主机提供通信服务**，同时**为分组选择合适的路由**，使源主机运输层所传下来的分组能够交付到目的主机。

   - 数据链路层

     数据链路层的任务是将在网络层交下来的数据报组**封装成帧**（frame)，在两个相邻结点间的链路上实现帧的**无差错传输**。

   - 物理层

     物理层的任务就是透明地**传输比特流**。“透明地传送比特流”指实际电路传送后比特流没有发生变化。物理层要考虑用多大的电压代表“1”或“0”，以及当发送端发出比特“1”时，接收端如何识别出这是“1”而不是“0”。物理层还要确定连接电缆的插头应当有多少根脚以及各个脚如何连接。

<img src="C:\Users\NHT\Desktop\前端复习\img\网络结构分层.png" alt="网络结构分层" style="zoom:60%;" />

7. **安全**

   - XSS跨站脚本攻击，**可以执行的代码注入到网页中** 

     常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动 ，持久性（注入数据库）、非持久型

     - 反射型 发出请求时，XSS代码出现在url中，作为输入提交到[服务器](http://msd.misuland.com/pd/3181438612956776236)端，服务器端解析后响应，XSS代码随响应内容一起传回给[浏览器](http://msd.misuland.com/pd/3181438612956776646)，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。
     - 存储型 存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（[数据库](http://msd.misuland.com/pd/3181438612956776842)、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。

     > 攻击：如：将js代码注入url

     > 防御： 最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行**转义**，或者白名单过滤

     - 编码： 对用户输入的数据进行 HTML Entity 编码。 Encode的作用是将等一些字符进行转化，使得浏览器在最终输出结果上是一样的。
     - 过滤： 移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。

   - CSRF跨站请求伪造，利用用户的**登录态**发起恶意请求 

     > 攻击：利用A网站的登录态（同一浏览器下的cookie），在B网站发送请求，取得后端的信任

     > 防御：不让第三方网站访问到cookie，请求带验证信息（token）
     
     token就是用来防CSRF的，cookie会被自动带上而token不会，token要配合session使用，不同的会话session不一样，验证自然不会通过。

8. 状态码和应用
   - 200成功并正常处理
   - **204**收到请求成功处理，但返回的响应报文不含主体部分（No Content）
   - **206**客户端进行了范围请求，可用于解决大文件下载问题（分割上传）
   - **301**永久性重定向，比如说换了域名
   - **302**临时性重定向，未登录跳到登录，404 跳到首页等
   - 304和重定向没关系
   - 400表示报文格式或者语法有错误，前端提交数据有问题
   - 401请求需要有通过 HTTP 认证的认证信息 ， 若之前已进行过 1 次请求， 则表示用户认证失败。 
   - 403禁止访问。未获得访问权限，你的IP被列入黑名单等等，服务端可以给出一个详细说明并返回。
   - 404
   - 500服务端有bug
   
9. HTTPS

   - 服务端和客户端，是一对多的关系
- 要做到安全，必须只有A和B才能看到传输的内容，就要用加密算法
   - 对称加密算法，不能所有的客户端都共用一套，所以需要分别协商
- 使用非对称加密算法，进行对称加密算法**协商**过程。非对称加密：服务端拿私钥，客户端们拿公钥，保证C-->S是安全的，但不保证S-->C是安全的（因为公钥有很多人都有）
   - 通过第三方机构使用他的私钥，对公钥加密，再传给客户端
   - 用随机数来生成对称加密算法。这样就可以做到服务器和客户端每次交互都是新的加密算法、只有在交互的那一该才确定加密算法。
   

**总结**： **对称加密算法加密数据+非对称加密算法交换密钥+数字证书验证身份=安全 **

>HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，
   >
   >但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，
   >
   >然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。
   >
   >这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。
   >
   >从而解决了客户端与服务器端之间的通信安全问题。

握手过程：

- SSL客户端（也是TCP的客户端）在TCP链接建立之后，发出一个ClientHello来发起握手，这个消息里面包含了（**客户端发起握手**）
   -- Client支持的SSL协议版本；
   -- Client生成的随机数c1，稍后用于生成"对话密钥"；
   -- Client支持的加密方法；
   -- Client支持的压缩方法；
- SSL的服务器端会回应一个ServerHello，这个消息里面包含了以下内容（**服务端给客户端发送公钥，非对称加密**）
   -- Server确认使用的加密通信协议版本；
   --  Server生成的随机数s1，稍后用于生成"对话密钥"；
   -- Server确认使用的加密方法；
   -- Server 的SSL证书。
- Client收到服务器回应以后，首先验证Server的证书是否有效，如果没问题，从证书里面取出Server的公钥，然后发送消息给Server（**客户端验证证书，取出公钥，加密密钥，发给服务端**），包含以下内容
   -- Client生成的随机数c2，需要注意的是，这个随机数c2是经过Server公钥加密过的；
   -- 告知Server 握手结束
- Server收到Client消息后，使用私钥解密Client发过来的第二个随机数，同时也会发送握手结束的消息给Client。（**服务端用私钥解密，取出密钥，完成对称加密协商**）

<img src="C:\Users\NHT\Desktop\前端复习\img\ssl握手.png" alt="ssl握手" style="zoom:80%;" />