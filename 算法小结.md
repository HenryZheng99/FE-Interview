# 算法

输入一个数m，求从1开始到m，不能被2或3整除的数有多少个？

**思路**：直接遍历会超时，不会预处理（剔除数组），所以找规律

思考：在1至100的整数中,能被2整除或能被3整除的数共有几个?

被2整除的有100/2=50个
被3整除的有99/3=33个
既能被2又能被3整除的有96/6=16个
所以共有50+33-16=67个

综上：倒着遍历，记录第一个被2、3、6整除的数，然后直接公式求值

```c++
#include <iostream> 
using namespace std;
int main()
{
    int n,m;
    cin>>n;//有多少组输入
    for(int i=0;i<n;i++){
      cin>>m;
      int count = 0;
      bool flag = true;
      int two =0,three=0,six=0,temp = m;
      while(flag){
         if(m%2==0 && two==0){
            two = m/2;
         }
         if(m%3==0 && three==0){
            three = m/3;
         }
         if(m%6==0 && six==0){
            six = m/6;
         }
         m--;
         if(m==1) flag = false;
         if(two!=0&&three!=0&&six!=0){
            flag = false;
         }
      }
      cout<<temp-two+six-three<<endl;
    }
    return 0;
}
```

超时的情况：比O(n)快的有二分法O(nlogn)、找规律（公式，O(1)）、预处理（eg.筛选法判断素数）、dfs剪枝等